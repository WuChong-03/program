# Sort(排序)

在编程中，ソート（Sort） 就是把一堆数据「按照某种规则」排列起来的操作。

比如：int arr[] = 

`{50, 80, 70, 100, 60}`;

把它从高到低排好，变成：

`{100, 80, 70, 60, 50}`

## 排序的作用:

排序不仅能让数据看起来更整齐，对搜索、统计、分析都很有帮助。

比如找最大/最小值排序后的有序数列可运用二分查找更快速等

## 排序的时间复杂度:
| 写法         | 叫法    | 通俗解释                    |
| ---------- | ----- | ----------------------- |
| O(n²)      | 平方级   | 每多一个元素，步骤数爆炸性增长（选择、冒泡等） |
| O(n log n) | 线性对数级 | 比 n² 快很多（归并、快速等）        |
| O(n)       | 线性级   | 步骤数 ≈ 元素个数              |
| O(log n)   | 对数级   | 增长超慢（比如二分查找）            |

## 常见的排序方式:

| ソート名（中文）      | 基本思路                        | 速度              | 特点简述                 |
| ------------- | --------------------------- | --------------- | -------------------- |
| バブルソート（冒泡排序）  |  每次比较相邻，把最小值慢慢冒到左端或右端边            | 非常慢（O(n²)）      | 最简单，适合入门，逻辑直观，但效率最低  |
| 選択ソート（选择排序）   | 每轮找出最小值，放到前面的位置             | 很慢（O(n²)）       | 实现简单，不稳定，交换次数少       |
| 挿入ソート（插入排序）   | 像打牌一样，依次把每个元素插入前面已有序的部分         | 慢（O(n²)）        | 数据小, 本身几乎有序时非常快，稳定      |
| シェルソート（希尔排序）  | 先分组插入排序，再逐步缩小间隔直到完整排序       | 中等（约O(n log n)） | 插入排序的升级版，性能比基础排序高    |
| マージソート（归并排序）  | 先分成小组排序，再合并成有序组，采用递归        | 快（O(n log n)）   | 稳定可靠，适合大数据，但需要额外空间   |
| クイックソート（快速排序） | 选一个基准，把小的放左边，大的放右边，递归处理     | 很快（O(n log n)）  | 实战中最常用，高效，但有可能退化为慢算法 |
| ヒープソート（堆排序）   | 把数据构造成最大堆（树结构），不断取出堆顶元素放到末尾 | 快（O(n log n)）   | 不需要额外空间，适合硬件、文件流处理等  |

# 各排序方法代码例:

## 1. バブルソート：

冒泡排序(逆向)：

- 循环 `size - 1` 次（外层 `i` 控制轮数），

- 每轮从数组最右侧开始，比较相邻的两个数：`arr[j - 1]` 和 `arr[j]`。

- 如果前一个比后一个大，就交换，通过 `j--` 逐步从右向左，把当前最小的值“推”到最左侧。

- 关于 i 和 j 的关系：每轮外层 `i++`，代表左侧有一个元素已经排好，不用再动。

    所以内层循环范围是 `j > i`：只在未排序区域中比较。

    也就是说： 第 i 轮，最小值被“泡”到了位置 arr[i] 上。

* 动画演示(正向冒泡版本):

    https://www.bilibili.com/video/BV1qY4y1h7Lz/?spm_id_from=333.788.recommend_more_video.-1&vd_source=6fe175454199ae00d5879189c354c8b2

### 代码演示(反向冒泡版本):
```c
int main() {
    int arr[] = {5, 3, 4, 1, 2};
    int size = sizeof(arr) / sizeof(arr[0]);    

    // 外层 i 控制总共进行几轮：从 0 到 size - 2，共执行 size - 1 轮
    for (int i = 0; i < size - 1; i++) {

        // 每一轮的目标：从还没排好的区域中，把“当前最小值”一步步往左推
        // j 从最后一个元素开始往左比较，直到 j > i（也就是排到 i 为止）
        for (int j = size - 1; j > i; j--) {

            // 如果左边比右边大，顺序错了 → 交换
            // 比如 j = 4 时，比 arr[3] 和 arr[4]
            if (arr[j - 1] > arr[j]) {
                int temp = arr[j - 1];
                arr[j - 1] = arr[j];
                arr[j] = temp;
            }   
        }

        // 一轮结束后，“当前最小的值”已经被推到了最左边（arr[i]）
        // 所以下一轮从 i + 1 开始，再推下一个最小值
    }
    return 0;
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```


### 2. 選択ソート

* 动画演示:

    https://www.bilibili.com/video/BV1qS4y1w7jM/?vd_source=6fe175454199ae00d5879189c354c8b2

* 程序演示:
```c
int main() {
    int arr[] = {5, 3, 4, 1, 2};
    int size = sizeof(arr) / sizeof(arr[0]);

    // 外层 i 控制第几轮，从 0 到 size - 2（共 size - 1 轮）
    for (int i = 0; i < size - 1; i++) {

        // 每轮开始前，先假设当前位置 i 就是最小值
        int minIndex = i;

        // 从 i+1 开始往后找更小的值
        for (int j = i + 1; j < size; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;  // 找到更小值 → 更新最小值的下标
            }
        }

        // 一轮找完后，minIndex 就是当前轮中最小值的位置
        // 把它和 i 位置的值交换，把最小的放到前面来
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;

        // 每轮结束后，arr[0 ~ i] 是排好序的区域，左边越来越有序
    }
```

### 3. 挿入ソート

* 动画演示:

    https://www.bilibili.com/video/BV1er4y1b7o4/?spm_id_from=333.337.search-card.all.click&vd_source=6fe175454199ae00d5879189c354c8b2

* 程序演示:
```c
    #include <stdio.h>

    int main() {
        int arr[] = {5, 3, 4, 1, 2};
        int size = sizeof(arr) / sizeof(arr[0]);

        // 外层循环：从第2个元素开始（因为第1个默认排好）
        for (int i = 1; i < size; i++) {

            int tmp = arr[i];       // 当前要插入的值
            int j = i - 1;          // 从已排序部分的最后一个开始往前找

            // 只要前面的数比当前tmp大，就把它往右移动
            while (j >= 0 && arr[j] > tmp) {
                arr[j + 1] = arr[j];  // 把 arr[j] 往右一格放
                j--;                  // 看前一个
            }

            // 找到合适位置，把当前tmp插入
            arr[j + 1] = tmp;
        }

        // 显示排好序的结果
        for (int i = 0; i < size; i++) {
            printf("%d ", arr[i]);
        }

        return 0;
    }

```

## 4.未完待续


