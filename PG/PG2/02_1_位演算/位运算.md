## 位运算 

### 🌿前言：二进制与内存

在计算机中，所有数据最终都以 二进制（0 和 1） 形式存储。
C 语言虽然没有“二进制类型”，但我们可以通过 int / char / unsigned int 来间接表示这些二进制位。

- char → 8 位
- int → 32 位

这些位在内存中就像一排小开关（bit）：

开 = 1，关 = 0

## 位运算的用途

在程序中，我们经常需要管理多个“开关状态”<br>
例如角色是否跳跃、是否受伤、是否无敌……

与其为每个状态单独声明一个变量<br>
不如把这些状态都 **压缩在同一个整数** 里，用“位（bit）”来表示。

```c
int playerState = 0;  // 初始状态：所有开关都关闭（00...000）
```

可以把这个32位的 `playerState` 当作拥有 32 个小开关 的 **状态管理器**，

每一位都可以表示一种状态
| 位位置   | 状态     | 二进制表示  | 含义   |
| ----- | ------ | ------ | ---- |
| 第 0 位 | SLEEP  | `0001` | 睡眠 |
| 第 1 位 | STONE  | `0010` | 石化 |
| 第 2 位 | POISON | `0100` | 中毒 |
| 第 3 位 | DEAD   | `1000` | 死亡 |

<br>

在程序开头，可以使用 #define、enum 或 const<br>
为每个状态定义对应的 **标志位（flag）**：

```c
const int SLEEP  = 1 << 0;   // 0001 (睡眠)
const int STONE  = 1 << 1;   // 0010 (石化)
const int POISON = 1 << 2;   // 0100 (中毒)
const int DEAD   = 1 << 3;   // 1000 (死亡)

//💡 左移（<<）与右移（>>）也是位运算符, 但其主要用于数学运算或生成掩码，例如 `1 << 3` 表示第3位（0000 1000）
```
- 打开状态 : `OR Flag`
    ```c
    playerState |= POISON;
    // playerState = 0000
    // POISON      = 0100
    // 0000 OR 0100 = 0100   ✅ 打开中毒位
    ```
- 关闭状态 : `AND + NOT Flag`

    ```c
    playerState &= ~SLEEP;
    // playerState = 0111   (睡眠+石化+中毒)
    // SLEEP       = 0001
    // ~SLEEP      = 1110
    // 0111 AND 1110 = 0110   ✅ 关闭睡眠位
    ```

- 检测状态 : `AND Flag`

    ```c
    if (playerState & DEAD) { printf("玩家已死亡。\n"); }
    // playerState = 1000
    // DEAD        = 1000
    // 1000 AND 1000 = 1000 ≠ 0000   ✅ 条件成立（为真）
    ```

- 切换状态 : `XOR Flag`
    ```c
    playerState ^= STONE;
    // playerState = 0000
    // STONE       = 0010
    // 0000 XOR 0010 = 0010   ✅ 打开石化位
    ```


### 实际例子: 

- **1️⃣main外部: 定义状态的全局常量**
    ```c
    #define FLAG_VISIBLE  0x01  //可见
    #define FLAG_MOVING   0x02  //移动
    #define FLAG_JUMPING  0x04  //跳跃
    #define FLAG_ATTACK   0x08  //攻击
    //以0x开头是一种专业习惯，用来区分普通数字和位操作用常量
    ```
- **2️⃣初始化: 初始化状态变量** 
    
   创建一个 int 类型的 player 状态变量，所有标志位初始为 0（即所有状态都关闭）：
    ```c
    int playerState = 0x00;
    ```
- **3️⃣更新处理: 通过输入或逻辑更新状态**
    ```c
    if (keys[DIK_SPACE]) {     // 跳跃键按下，打开跳跃标志
        playerState |= FLAG_JUMPING; 
    } else {                   // 松开时关闭跳跃标志
        playerState &= ~FLAG_JUMPING;  
    }        
    ```
- **4️⃣更新处理: 用 AND 检查状态并更新逻辑**
    ```c
    if (playerState & FLAG_JUMPING) {
        velocityY = -10; // 应用跳跃力
    }
    ```

- **5️⃣描画处理: 根据状态执行表现**
    ```c
    if (playerState & FLAG_JUMPING) {
        DrawSprite(.....);
    }
    ```


### 如何调试

如前文所述,printf无法打印2进制,如果想看内存里具体哪一位是 1 哪一位是 0，需要用“二进制打印函数`printBit2()`”把整数展开成 0/1 的序列，这就和前面说的二进制紧密连接了。
