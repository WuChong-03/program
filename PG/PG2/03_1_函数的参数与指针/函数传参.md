## 函数传参

### 🌿基本概念

在编程中，我们编写的函数大致可以分为两类：

- **看数据** : 例如计算距离、打印信息等。

- **改数据** : 例如回血、加经验、得分等。

这两类函数的最大区别就在于——

>👉 **调用函数时，传入的变量值是否会被改变**。

这种行为取决于函数定义时**形参**的形式：

如果是 **值传递**，函数只接收一份“副本”，不会改动原值。

如果是 **指针传递**，函数接收的是变量的“地址”，可以直接修改原始数据。



## 🍎 值传递

```c
void add(int a) {
    a++;
    printf("函数内 a = %d\n", a);
}

int main(void) {
    int num = 10;
    add(num);                         //函数内 a = 11
    printf("函数外 num = %d\n", num); //函数外 num = 10
}
```

- 当我们在调用函数时，如果把变量作为 **实参** 传入，
系统会将这个外部变量的值 **复制一份** 传给函数内部的 **形参**。

- 函数内部对该值所做的任何修改，
就像作用域中局部变量一样——只在函数 `{}` 内有效，
**不会影响**外部原变量的值。

    📘这就是“值传递”的本质。

---

## 🍎 指针传递

```c
void AddApple(int *a) {         //等实参传地址过来
    if (a == nullptr) return;   //安全保险.
    *a += 1;
    printf("函数内 *a = %d\n", *a);
}

int main(void) {
    int apple = 1;
    AddApple(&apple); //  传变量地址; 函数内 *a = 2
    printf("调用后  apple = %d\n", apple); // 调用后 apple = 2
}
```

- 如果在定义函数时，形参不是“值”，<br>
而是使用 `int *` 来声明的“地址参数”，<br>
那么在调用函数时，实参也必须是一个“地址参数”。（使用 & 取得变量的地址）

- `&apple` 取得apple地址,作为实参传入函数，<br>
函数内部通过 `*a` 访问其地址,并修改该地址所指向的实际值。<br>
因此，外部变量本身也会随之改变。

- `if (a == NULL)` 是 C 语言风格的空指针检查，
- `if (a == nullptr)` 是 C++11 之后更安全的写法，

    ### 关于scanf_s
        scanf_s 的 & 就是取地址符，表示“把用户输入的内容存入变量 n 所在的内存地址中”。
        因为 scanf_s() 是通过指针传递（即地址传递）来修改变量的值的，所以必须传入变量的地址。

---

## 🍎 *引用传递
```c
#include <stdio.h>

void AddApple(int &a) {   // &a,等实参亲自过来再取他地址
    a += 1;               // 直接修改外部变量的值
    printf("%d\n", a);    
}

int main() {
    int apple = 1;
    AddApple(apple);         // 传变量本身
    printf("%d\n", apple);   // 2 
    return 0;
}
```
- “引用传递”与“指针传递”本质上做的事情相同,
👉 都是让函数直接访问实参在内存中的地址

- 但引用传递在语法上更自然，不需要使用 * 或 &，
看起来就像在操作普通变量一样。

- ⚠️ 仅在 C++ 中可用，C语言里编译会出错。

---

## 函数传参与const

因为值传递在访问大型数据时会浪费性能，
所以指针传递和引用传递也经常被用于“查看”或“读取”数据

为了防止不小心造成的值被修改在定义函数时加一个const(只读)会更安全.
```c
#include <stdio.h>

void PrintNumber(int* num) {
    printf("读取到的值是: %d\n", *num);
    *num = 999; // ❌ 不小心改了！
}

int main(void) {
    int a = 10;
    PrintNumber(&a);
    printf("main 中 a = %d\n", a); // a 被改成 999 了
    return 0;
}
```
```c
#include <stdio.h>

void PrintNumber(const int* num) {
    printf("读取到的值是: %d\n", *num);
    *num = 999; // ❌ 报错：不能修改 const 指针所指的内容
}

int main(void) {
    int a = 10;
    PrintNumber(&a);
    printf("main 中 a = %d\n", a); // a 依然是 10
    return 0;
}
```
## 课题应用
```c
#include <Novice.h>

const char kWindowTitle[] = "GC1B_03_ゴ_チュウ";

void Move(float& posX, float& posY, float& speed , char keys[256]);
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {

	Novice::Initialize(kWindowTitle, 1280, 720);
	char keys[256] = { 0 };
	char preKeys[256] = { 0 };

	float playerX = 640.0f;
	float playerY = 320.0f;
	float playerSpeed = 15.0f;

	while (Novice::ProcessMessage() == 0) {
		Novice::BeginFrame();
		memcpy(preKeys, keys, 256);
		Novice::GetHitKeyStateAll(keys);

		// 更新処理
		Move(playerX,playerY,playerSpeed,keys);

		// 描画処理
		Novice::DrawEllipse((int)playerX, (int)playerY, 32, 32, 0.0f, WHITE, kFillModeSolid);

		Novice::EndFrame();

		if (preKeys[DIK_ESCAPE] == 0 && keys[DIK_ESCAPE] != 0) {
			break;
		}
	}

	Novice::Finalize();
	return 0;
}
void Move(float& posX, float& posY, float& speed, char keys[256]) {
	if (keys[DIK_W]) posY -= speed;
	if (keys[DIK_S]) posY += speed;
	if (keys[DIK_A]) posX -= speed;
	if (keys[DIK_D]) posX += speed;
}
```

