## 什么是数据结构　(データ構造)

为了让电脑更快更方便地处理数据，我们要用合适的方式来安排和保存这些数据

### 代表性的数据结构有以下几种

| 名称（日文）       | 简单说明             | 举例或比喻            |
| ------------ | ---------------- | ---------------- |
| **配列 (数组)** | 把数据一排排放在一起，用编号取出 | 像一排储物柜，用编号拿东西    |
| **リスト（链表）**  | 数据一个接一个地连起来      | 像一串链条，每个环都连着下一个  |
| **スタック（堆栈）** | 后进去的先出来（LIFO）    | 像叠盘子，最后放的先拿      |
| **キュー（队列）**  | 先进去的先出来（FIFO）    | 像排队买票，先到先服务      |
| **木（き）**     | 有层次结构，可以分支展开     | 像家谱或文件夹结构，一层层往下分 |

## 1) 配列
### 🌿基本概念
```c
int score[5] = {95, 100, 75, 75, 85};
```
array 是一种把多个同类型数据整齐排在一起来管理的方法。<br>
在编程中我们用像上面这样的写法来表示 (索引编号从 0 开始) <br>

但它的本质其实就是——把很多相似的数据放进一条有编号的“队列”里。

📘 在内存中，数组的所有数据会连续排成一行，就像一排储物柜，每个格子里放一个数，编号从 0 开始，一个接一个紧贴排列。

---

### 🌿多维数组:

```c
int score[3][4] = {
    {80, 90, 70, 60},
    {90, 90, 70, 80},
    {100, 80, 70, 50}
};
```
当我们想处理“表格”或“地图”这类具有行与列的数据时，
就可以使用 多维数组。
它可以看作是“由多个一维数组叠加形成的结构”，
让数据排列成“行 × 列”的形式，更直观地表示位置关系。

例如上面的 score[3][4] 表示一个 3 行 × 4 列 的整数表格。

📘 实际上，多维数组在内存中仍然是连续存放的，
只是我们在逻辑上把它划分成了「行」与「列」，
这样在编程时就能更自然地处理二维或三维的数据结构。

👉不管是一维数组还是多维数组,核心思想都是: <br>
**用连续的空间来高效地管理多个相似数据**


## 2) リスト

### 🌿 基本概念

list 是一种通过 Pointer (指针) 把数据一个一个连接起来的结构。<br>
与数组不同的是，数组的数据在内存中是一条**连续的**直线，而链表的数据分散在不同位置，<br>

> TOP → [Data1 | →] → [Data2 | →] → [Data3 | null]

和array不同, list的每个节点里都有两样东西——

- 自己的数据: Data1/2/3

- 指向下一个数据地址的箭头: → (Pointer)

因此它们仍然可以按顺序连接。

最前面的节点称为 **TOP（头指针）**，
它负责指向第一个数据；<br>
最后一个节点的指针通常是空的（null 或 0），表示“到此为止”。

---

### 🌿 list的种类

- **単方向list**

    > TOP → [1] → [2] → [3] → null

    数据只能朝一个方向连接的链表，也叫 线形链表（線形リスト）。
    每个节点只知道“下一个节点”的位置，
    所以访问顺序只能是「从头到尾」。

- **双方向list**

    > TOP ⇄ [1] ⇄ [2] ⇄ [3] ⇄ BOT

    在每个节点中同时保存：

    - “下一个节点”的指针（next）
    - “前一个节点”的指针（prev）

    因此可以双向移动：从前往后，也能从后往前。

📘 双向链表比单向链表更灵活，但需要更多内存来保存两个指针。

---

## 配列とリストの比較

数组（Array）和链表（List）虽然都是用来存放一组数据的结构，
但它们在访问速度、插入删除效率、内存利用等方面各有优缺点。
下面我们从三个角度进行比较：

1. 数据访问速度
2. 数据的追加与删除
3. 内存利用与灵活性

### ① 数据访问速度

- 数组：访问快（可直接定位）

        数组中的数据在内存中是连续存放的，因此可以直接通过索引一次性访问目标数据。

- 链表：访问慢（必须逐个找）

        链表中的数据是一个一个通过指针连接起来的，
        要访问中间的某个元素，必须从头开始顺着指针逐个查找。


### ② 数据的追加与删除

- 数组：插入/删除慢（需要移动数据）

        数组是连续存放的，一旦在中间插入或删除数据，
        后面的所有数据都要“往后或往前挪动”。
        这会浪费时间。

- 链表：插入/删除快（只改指针）

        链表中，每个节点只保存一个指向下一个节点的指针。
        插入或删除只需修改相关节点的指针连接即可，
        不需要移动其它数据。

### ③ 内存利用与灵活性

- 数组：一次性分配固定大小 → 可能浪费空间

        数组在声明时必须指定长度: int arr[100];
        即使只用了其中10个，也会占用100个空间，
        这样会造成浪费的空白区域。

- 链表：动态扩展或缩小 → 节省空间

        链表是动态创建的，
        只在需要时才生成节点，
        可以自由增加或减少，不容易浪费内存。

---

### 总结: 

📘 如果程序中是频繁读取数据、修改较少，
→ 数组（Array） 更合适。

📘 如果程序中是频繁插入、删除、动态变化多，
→ 链表（List） 更合适。

### 各操作效率图标

| 操作                   | 数组 Array       | 链表 List        | 原因说明                   |
| -------------------- | -------------- | -------------- | ---------------------- |
| **访问 (Access / 参照)** | ✅ **快 (O(1))** | ❌ **慢 (O(n))** | 数组通过索引可直接定位；链表要一个个顺着找。 |
| **更新 (Update)**      | ✅ **快 (O(1))** | ❌ **慢 (O(n))** | 更新前要先找到节点 → 访问慢 → 总体慢。 |
| **插入 (Insert)**      | ❌ **慢 (O(n))** | ✅ **快 (O(1))** | 数组插入要移动后面元素；链表只改指针连接。  |
| **删除 (Delete)**      | ❌ **慢 (O(n))** | ✅ **快 (O(1))** | 数组删除后要把后面元素前移；链表只断开连接。 |
| **顺序遍历 (Traversal)** | ✅ **快**        | ✅ **快**        | 两者都可以顺序扫描，差别不大。        |
| **内存利用 (Memory)**    | ❌ 固定、易浪费       | ✅ 动态、灵活        | 数组长度固定；链表随用随建。         |
