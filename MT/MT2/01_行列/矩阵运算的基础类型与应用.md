# Matrix

# 前言

- 本课程以 2D 为主，学习「矩阵（Matrix）」的基础。

    - 通过在 游戏制作 中的使用来掌握矩阵。
    - 矩阵是从2D走向3D的桥梁，掌握矩阵运算能让你在未来3D编程中快速上手。

- 课程目标： 理解 Matrix 的本质 → 掌握矩阵运算 → 将其应用到游戏制作中的“位置、旋转、缩放、平移”等变换中。

<br>
<br>

## 为什么要用到 Matrix

- **我们在游戏中频繁进行缩放、旋转、平移等操作。<br> 这些都可以各自用公式实现：**

    | 操作  | 公式 | 问题 |
    | -----| -   |  -   |
    | 缩放 | `(x', y') = (kx, ky)`| 只能放大/缩小，不能旋转或移动 |
    | 旋转 | `x' = xcosθ - ysinθ`<br>`y' = xsinθ + ycosθ` | 只能绕原点旋转，不能平移    |
    | 平移 | `(x', y') = (x + tx, y + ty)`              | 只能移动，不能旋转       |

<br>

- **但当我们要同时做多个变换（比如“旋转缩放后再移动”）时，公式就得一层套一层：**
    ```c
    x' = (x*cosθ - y*sinθ) * s + tx
    y' = (x*sinθ + y*cosθ) * s + ty
    ```

    这太麻烦，也难维护。

    于是数学家就问了一个关键问题：“能不能把这些操作都统一成一种写法？”

    : Matrix 登场了。

<br>

- **Matrix 让所有几何操作都能用一种统一的数学方式表达出来：**

     ### `v′= M ⋅ v`
    
<br>

- **利用自作函数构建矩阵，无论你要做旋转、平移还是缩放，只需更换不同的矩阵，或将它们合成为一个 Matrix 即可。**

例如:

### `Vector2 newPos = Matrix( M , oldPos );`

✅ 从此再也不用手动写一堆复杂的三角函数公式，
    只要定义好矩阵函数 Matrix()，让程序自动带入参数执行乘法，就能完成所有变换


<br>
<br>

# 矩阵乘法的数学公式规律

### 乘法核心原则：「行 × 列」

- 矩阵 × 矩阵

    每一个新矩阵的元素，都是由「左矩阵的一行」与「右矩阵的一列」相乘后再相加得到的。
    （见图：矩阵乘法.png）

- 矩阵 × 向量

    向量下 |x , y| 可以被视为一个横着写的两列的 “一维矩阵”，
    其计算方式与矩阵乘法完全相同。
    （见图：矩阵乘法2.png）

- 矩阵 × 标量

    矩阵的每一个元素都乘上同一个标量（数值）即可，
    结果仍然是一个新的矩阵。

> ✅ 这三种乘法本质上都遵循同一个规律——  
> **“行乘列、乘完加”**。  
> 只要理解了这一点，无论是 2×2、3×3 还是 4×4 矩阵，计算方法都完全一致。

<br>
<br>

# Matrix 的函数实装尝试

```c
#include <Novice.h>                 
#include <cmath> 

const char kWindowTitle[] = "GC1C_02_ゴ_チュウ"; 

// 基本结构体定义
	// 二维向量(x, y) 结构体
	struct Vector2 {
		float x;           
		float y;          
	};
	// 2x2 矩阵结构体
	struct Matrix2x2 {
		float m[2][2];       // m[row][col]
	};


// 自作函数构建矩阵

	// 生成单位矩阵：不改变任何向量（相当于“乘以 1”）
 	// 使用结构体类型定义函数
	Matrix2x2 MakeIdentity2() {    
	// ⚙️ 函数的返回类型和结构体“身材”必须一致（2x2矩阵）
		Matrix2x2 I{};             
		I.m[0][0] = 1; I.m[0][1] = 0; 
		I.m[1][0] = 0; I.m[1][1] = 1;  
		return I;                    
	}


	// 生成 2D 旋转矩阵：让向量绕原点旋转 theta（弧度）
	Matrix2x2 MakeRotate2D(float theta) {
		Matrix2x2 R{};                  
		float c = cosf(theta);       // cosθ
		float s = sinf(theta);       // sinθ
		R.m[0][0] = c;  R.m[0][1] = -s; 
		R.m[1][0] = s;  R.m[1][1] = c;
	//MakeRotate2D() 并不直接旋转点，
	//而是“造出一个会旋转的工具箱（矩阵R）”。
	//想让它真的旋转点，还要调用 MulMat2Vec2() 把工具用在向量上。
		return R;                        // 返回旋转矩阵
	}


	// 矩阵 × 向量（加工厂）


// Mul:乘法  Mat2:2x2矩阵  Vec2:2维向量
// 功能：计算 r = M * v（把矩阵作用在向量上）
Vector2 MulMat2Vec2(Matrix2x2 M, Vector2 v) {
	Vector2 r{};                     // 结果向量 r（先清零）

	// 计算新 x 分量：第 1 行 × 列向量
	r.x = M.m[0][0] * v.x + M.m[0][1] * v.y;
	// 计算新 y 分量：第 2 行 × 列向量
	r.y = M.m[1][0] * v.x + M.m[1][1] * v.y;

	return r;                        // 把新向量返回给调用者
}

//====================//
// Windows 入口函数
//====================//
int WINAPI WinMain(_In_ HINSTANCE hInstance,            // Windows 句柄（系统传入）
                   _In_opt_ HINSTANCE hPrevInstance,    // 旧实例句柄（保留，恒为空）
                   _In_ LPSTR lpCmdLine,                // 命令行参数
                   _In_ int nCmdShow)                   // 窗口显示方式
{
	Novice::Initialize(kWindowTitle, 1280, 720);        // 初始化 Novice：创建 1280x720 窗口

	char keys[256] = { 0 };                              // 当前帧键盘状态缓存
	char preKeys[256] = { 0 };                           // 上一帧键盘状态缓存

	// 点的初始位置：从原点（0,0）向右 200 的向量（将被当作“要变换的向量”）
	Vector2 pos = { 200.0f, 0.0f };

	// 当前旋转角度（弧度），初始为 0
	float theta = 0.0f;

	// 主循环：直到窗口关闭
	while (Novice::ProcessMessage() == 0) {              // 处理系统消息（返回 0 表示继续）
		Novice::BeginFrame();                            // 开始一帧（清屏/准备渲染）

		memcpy(preKeys, keys, 256);                      // 备份上一帧键盘状态
		Novice::GetHitKeyStateAll(keys);                 // 读取当前帧键盘状态

		//--------------------------------
		// ↓ 更新处理（游戏逻辑）
		//--------------------------------

		// 按住空格键则不断增加角度：实现持续旋转
		if (keys[DIK_SPACE]) {                           // 如果本帧 SPACE 被按住
			theta += 0.05f;                              // 角速度：每帧加 0.05 弧度
		}

		// 构建旋转矩阵 R（外部变量名 R）
		Matrix2x2 R = MakeRotate2D(theta);               // 用当前角度生成旋转矩阵
		// 把 R 作用在向量 pos 上，得到变换后的位置 newPos
		Vector2 newPos = MulMat2Vec2(R, pos);            // 这里把 R 传给函数的形参 M

		//--------------------------------
		// ↓ 绘制处理（渲染到屏幕）
		//--------------------------------

		// 从屏幕中心 (640,360) 画到 (640+newPos.x, 360-newPos.y) 的白线
		// 注意：屏幕 y 轴向下为正，因此要用 (360 - y) 把数学坐标转为屏幕坐标
		Novice::DrawLine(
			640, 360,                                    // 起点：屏幕中心
			640 + static_cast<int>(newPos.x),            // 终点 x：中心 + 旋转后 x
			360 - static_cast<int>(newPos.y),            // 终点 y：中心 - 旋转后 y（屏幕坐标系修正）
			0xFFFFFFFF                                   // 颜色：白色（ARGB）
		);

		// 左上角 HUD：提示与调试信息
		Novice::ScreenPrintf(10, 10, "Press SPACE to rotate");        // 提示：按空格旋转
		Novice::ScreenPrintf(10, 30, "theta: %.2f", theta);           // 显示当前角度
		Novice::ScreenPrintf(10, 50, "newPos.x: %.2f, newPos.y: %.2f",// 显示旋转后向量
		                     newPos.x, newPos.y);

		Novice::EndFrame();                             // 结束一帧（提交渲染/交换缓冲）

		// 如果本帧 ESC 被按下（上一帧没按，这一帧按了），就退出循环
		if (preKeys[DIK_ESCAPE] == 0 && keys[DIK_ESCAPE] != 0) {
			break;                                       // 退出主循环
		}
	}

	Novice::Finalize();                                  // 释放 Novice 资源，关闭窗口
	return 0;                                            // 进程结束（返回给操作系统）
}
```
